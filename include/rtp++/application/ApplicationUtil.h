#pragma once
#include <string>
#include <boost/optional.hpp>
#include <cpputil/FileUtil.h>
#include <cpputil/StringTokenizer.h>
#include <rtp++/media/h264/H264AnnexBStreamWriter.h>
#include <rtp++/media/h265/H265AnnexBStreamWriter.h>
#include <rtp++/media/MediaSample.h>
#include <rtp++/mediasession/SimpleMediaSession.h>
#include <rtp++/mediasession/SimpleMediaSessionV2.h>
#include <rtp++/network/AddressDescriptorParser.h>
#include <rtp++/rfc4566/SdpParser.h>

namespace rtp_plus_plus
{
namespace app
{

/**
 * @brief The ApplicationUtil class contains common
 * methods that are used by the RtpSender, RtpReceiver, etc applications.
 */
class ApplicationUtil
{
public:
  /**
   * @brief printApplicationInfo
   * @param argc
   * @param argv
   */
  static void printApplicationInfo(int argc, char** argv);
  /**
   * @brief readNetworkConfigurationFile
   * @param sConfigFile
   * @return
   */
  static boost::optional<InterfaceDescriptions_t> readNetworkConfigurationFile(const std::string& sConfigFile, bool bRtcpMux);
  /**
   * @brief parseNetworkConfiguration
   * @param sConfig
   * @return
   */
  static boost::optional<InterfaceDescriptions_t> parseNetworkConfiguration(const std::string& sConfig, bool bRtcpMux);
  /**
   * @brief readNetworkConfigurationFiles
   * @param configFiles
   * @param bError
   * @return
   */
  static std::vector<InterfaceDescriptions_t> readNetworkConfigurationFiles(const std::vector<std::string>& configFiles, bool& bError, bool bRtcpMux);
  /**
   * @brief readSdp
   * @param sSdpFile
   * @param bVerbose
   * @return
   */
  static boost::optional<rfc4566::SessionDescription> readSdp(const std::string& sSdpFile, bool bVerbose = false);
  /**
   * @brief readSdps
   * @param vSdpFiles
   * @param bVerbose
   * @param bError
   * @return
   */
  static std::vector<rfc4566::SessionDescription> readSdps(const std::vector<std::string>& vSdpFiles, bool bVerbose, bool& bError);
  /**
   * @brief checkAndInitialiseSource
   * @param sSource
   * @param bGen
   * @param bStdin
   * @param in1
   * @return
   */
  static bool checkAndInitialiseSource(const std::string& sSource, bool& bGen, bool& bStdin, std::ifstream& in1);
  /**
   * @brief handleIncomingSample Utility method that accepts incoming samples and writes them to the passed in stream.
   * This method takes care of writing the start codes.
   * @param mediaSample The media samples that was received
   * @param out The stream that the NAL unit should be written to
   */
  static void handleIncomingH264MediaSample(const media::MediaSample& mediaSample, std::ostream& out);
  /**
   * @brief handleIncomingSample Utility method that accepts incoming samples and writes them to the passed in stream.
   * This method takes care of writing the start codes.
   * @param mediaSample The media samples that was received
   * @param out The stream that the NAL unit should be written to
   */
  static void handleIncomingH265MediaSample(const media::MediaSample& mediaSample, std::ostream& out);
  /**
   * @brief handleIncomingH264AccessUnit
   * @param mediaSamples
   * @param out
   */
  static void handleIncomingH264AccessUnit(const std::vector<media::MediaSample>& mediaSamples, std::ostream& out);
  /**
   * @brief handleIncomingH265AccessUnit
   * @param mediaSamples
   * @param out
   */
  static void handleIncomingH265AccessUnit(const std::vector<media::MediaSample>& mediaSamples, std::ostream& out);
  /**
   * @brief handleIncomingSample Utility method that accepts incoming samples and writes them to the passed in stream
   * @param mediaSample The media samples that was received
   * @param out The stream that the raw media sample should be written to
   */
  static void handleIncomingMediaSample(const media::MediaSample& mediaSample, std::ostream& out);
  /**
   * @brief handleVideoSample This callback should be called when a video media sample is generated and should be sent.
   * @param mediaSample The media sample that was generated by the media source. The media sample can e.g. contain a NAL unit.
   * @param pMediaSession The session in which the media sample should be delivered
   * @return boost::system::error_code()
   */
  static boost::system::error_code handleVideoSample(const media::MediaSample& mediaSample, boost::shared_ptr<SimpleMediaSession> pMediaSession);
  /**
   * @brief handleVideoAccessUnit This callback should be called when an entire Access Unit is generated and should be sent.
   * @param mediaSamples The media sample that was generated by the media source. The media sample can e.g. contain a NAL unit.
   * @param pMediaSession The session in which the media sample should be delivered
   * @return boost::system::error_code()
   */
  static boost::system::error_code handleVideoAccessUnit(const std::vector<media::MediaSample>& mediaSamples, boost::shared_ptr<SimpleMediaSession> pMediaSession);
  /**
   * @brief handleAudioSample This callback should be called when an audio media sample is generated and should be sent.
   * @param mediaSample The media sample that was generated by the media source. The media sample can e.g. contain a NAL unit.
   * @param pMediaSession The session in which the media sample should be delivered
   * @return boost::system::error_code()
   */
  static boost::system::error_code handleAudioSample(const media::MediaSample& mediaSample, boost::shared_ptr<SimpleMediaSession> pMediaSession);
  /**
   * @brief handleMediaSourceEof Handles the EOF of the media source, or the CTRL-C event
   *
   * This function is to be used with ConsoleApplicationUtil's startEventLoop. has two entry points: it can be called when it is EOF.
   * In that case we want to stop the running media session.
   * @param ec
   * @param pMediaSession
   */
  static void handleMediaSourceEof(const boost::system::error_code& ec, boost::shared_ptr<SimpleMediaSession> pMediaSession);
  /**
   * @brief handleApplicationExit Eof Handles the EOF of the media source, or the CTRL-C event
   *
   * This function is to be used with ConsoleApplicationUtil's startEventLoop. has two entry points: it can be called when it is EOF.
   * In that case we want to stop the running media session.
   * @param ec
   * @param pMediaSession
   */
  static void handleApplicationExit(const boost::system::error_code& ec, boost::shared_ptr<SimpleMediaSession> pMediaSession);
  /**
   * @brief parseMediaSampleSizeString Helper method to parse the desired sizes of generated media samples
   * @param sSizes String containing the sizes of the media samples seperated by '|'
   * @return a vector containing the sizes of the media samples
   */
  static std::vector<uint32_t> parseMediaSampleSizeString(const std::string& sSizes);
  /**
   * @brief initialiseFileMediaSource opens the file media source for reading if the file exists
   * @param in1 The ifstream used to open the file
   * @param sSource The file name
   * @return true if the file exists and false otherwise
   */
  static bool initialiseFileMediaSource(std::ifstream& in1, const std::string& sSource);
  /// V2
  /**
   * @brief handleVideoSample This callback should be called when a video media sample is generated and should be sent.
   * @param mediaSample The media sample that was generated by the media source. The media sample can e.g. contain a NAL unit.
   * @param pMediaSession The session in which the media sample should be delivered
   * @return boost::system::error_code()
   */
  static boost::system::error_code handleVideoSampleV2(const media::MediaSample& mediaSample, boost::shared_ptr<SimpleMediaSessionV2> pMediaSession);
  /**
   * @brief handleVideoAccessUnit This callback should be called when an entire Access Unit is generated and should be sent.
   * @param mediaSamples The media sample that was generated by the media source. The media sample can e.g. contain a NAL unit.
   * @param pMediaSession The session in which the media sample should be delivered
   * @return boost::system::error_code()
   */
  static boost::system::error_code handleVideoAccessUnitV2(const std::vector<media::MediaSample>& mediaSamples, boost::shared_ptr<SimpleMediaSessionV2> pMediaSession);
  /**
   * @brief handleAudioSample This callback should be called when an audio media sample is generated and should be sent.
   * @param mediaSample The media sample that was generated by the media source. The media sample can e.g. contain a NAL unit.
   * @param pMediaSession The session in which the media sample should be delivered
   * @return boost::system::error_code()
   */
  static boost::system::error_code handleAudioSampleV2(const media::MediaSample& mediaSample, boost::shared_ptr<SimpleMediaSessionV2> pMediaSession);
  /**
   * @brief handleMediaSourceEof Handles the EOF of the media source, or the CTRL-C event
   *
   * This function is to be used with ConsoleApplicationUtil's startEventLoop. has two entry points: it can be called when it is EOF.
   * In that case we want to stop the running media session.
   * @param ec
   * @param pMediaSession
   */
  static void handleMediaSourceEofV2(const boost::system::error_code& ec, boost::shared_ptr<SimpleMediaSessionV2> pMediaSession);
  /**
   * @brief handleApplicationExit Eof Handles the EOF of the media source, or the CTRL-C event
   *
   * This function is to be used with ConsoleApplicationUtil's startEventLoop. has two entry points: it can be called when it is EOF.
   * In that case we want to stop the running media session.
   * @param ec
   * @param pMediaSession
   */
  static void handleApplicationExitV2(const boost::system::error_code& ec, boost::shared_ptr<SimpleMediaSessionV2> pMediaSession);

};

} // app
} // rtp_plus_plus

#pragma once
#include <rtp++/media/MediaSource.h>

namespace rtp_plus_plus
{
namespace media
{

// The following payload types can be generated by the application
enum PayloadType
{
  PT_RAND,
  PT_CHAR,
  PT_NTP
};

static PayloadType parsePayload(const std::string& sPayload)
{
  if (sPayload == "rand")
    return PT_RAND;
  else if (sPayload == "char")
    return PT_CHAR;
  else if (sPayload == "ntp")
    return PT_NTP;
  // default
  return PT_RAND;
}

class GeneratedMediaSource : public MediaSource
{
public:
  /**
   * @brief Constructor
   */
  GeneratedMediaSource(PayloadType ePayloadType, const std::string& sPacketSizes, uint8_t uiCharPayload, uint32_t uiTotalVideoSamples);
  /**
   * @brief Overridden from MediaSource. isGood() returns if data can be read.
   * @return if the MediaSource is in a state to be read from
   */
  bool isGood() const;
  /**
   * @brief Overridden from MediaSource. getNextMediaSample() returns the next media sample in the source.
   * @return The next access unit in the source and an empty vector if isGood() == false
   */
  boost::optional<MediaSample> getNextMediaSample();
  /**
   * @brief Overridden from MediaSource. getNextAccessUnit() returns the next access unit in the source.
   * @return The next access unit in the source and an empty vector if isGood() == false
   */
  std::vector<MediaSample> getNextAccessUnit();

private:
  
  void initialiseMediaSamples();

private:

  PayloadType m_ePayloadType;
  std::vector<unsigned> m_vPacketSizes;
  // char payload
  uint8_t m_uiCharPayload;
  // Total number of samples to generate
  uint32_t m_uiTotalVideoSamples;
  // state
  uint32_t m_uiOutputCount;
  // index to last size output
  uint32_t m_uiSizeIndex;
  // single media sample to be sent for now
  MediaSample m_mediaSample;
  std::vector<MediaSample> m_vSamples;
};

} // media
} // rtp_plus_plus
